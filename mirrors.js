// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var ControlPoint, Lazer, Manager, Mirror, Vec2, info, min_by_key, warn;

  min_by_key = function(key, xs) {
    var best, best_key, x, x_key, _i, _len;

    best = null;
    best_key = null;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      x_key = key(x);
      if (best === null || x_key < best_key) {
        best = x;
        best_key = x_key;
      }
    }
    return best;
  };

  warn = function(message) {
    $('#status').html($('<span>').addClass('warn').html(message));
    return console.log('WARN:', message);
  };

  info = function(message) {
    $('#status').html($('<span>').addClass('info').html(message));
    return console.log('INFO:', message);
  };

  Vec2 = (function() {
    function Vec2(x, y) {
      this.x = x;
      this.y = y;
    }

    Vec2.prototype.dot = function(v) {
      if (v instanceof Vec2) {
        return this.x * v.x + this.y * v.y;
      } else {
        return new Vec2(this.x * v, this.y * v);
      }
    };

    Vec2.prototype.cross = function(v) {
      return this.x * v.y - this.y * v.x;
    };

    Vec2.prototype.minus = function(v) {
      return new Vec2(this.x - v.x, this.y - v.y);
    };

    Vec2.prototype.plus = function(v) {
      return new Vec2(this.x + v.x, this.y + v.y);
    };

    Vec2.prototype.length = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    return Vec2;

  })();

  ControlPoint = (function() {
    function ControlPoint(paper, v) {
      var end, move, start,
        _this = this;

      this.v = v;
      start = function(x, y, e) {
        _this._x0 = _this.v.x;
        return _this._y0 = _this.v.y;
      };
      end = function(x, y, e) {
        delete _this._x0;
        return delete _this._y0;
      };
      move = function(dx, dy, x, y, e) {
        _this.set(new Vec2(_this._x0 + dx, _this._y0 + dy));
        if (_this._on_move != null) {
          return _this._on_move();
        }
      };
      this.control = paper.circle(this.v.x, this.v.y, 3).attr({
        stroke: "#000",
        strokeWidth: 1,
        fill: "#fff"
      }).drag(move, start, end);
      this._on_move = null;
    }

    ControlPoint.prototype.set = function(v) {
      this.v = v;
      this.control.attr('cx', this.v.x);
      return this.control.attr('cy', this.v.y);
    };

    ControlPoint.prototype.remove = function() {
      return this.control.remove();
    };

    ControlPoint.prototype.move = function(func) {
      return this._on_move = function() {
        return func();
      };
    };

    return ControlPoint;

  })();

  Lazer = (function() {
    function Lazer(paper, v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
      this.start = new ControlPoint(paper, this.v1);
      this.end = new ControlPoint(paper, this.v2);
      this.line_origin = paper.path([]).attr({
        stroke: '#f88',
        strokeWidth: 0.2
      });
      this.line = paper.path([]).attr({
        stroke: '#88f',
        strokeWidth: 0.5
      });
    }

    Lazer.prototype.remove = function() {
      var obj, _i, _len, _ref, _results;

      _ref = [this.start, this.end, this.line, this.line_origin];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        _results.push(obj.remove());
      }
      return _results;
    };

    Lazer.prototype.update = function(mirrors) {
      var EPS, MAX_HIT_COUNT, cross, get_t, hit_count, mid, mid_point, min_mirror, min_t, path, reflect, v0, v1;

      EPS = 1e-6;
      MAX_HIT_COUNT = 100000;
      cross = function(v1, v2, v3, v4) {
        var d0, t1, t2;

        d0 = v2.minus(v1).cross(v3.minus(v4));
        if (Math.abs(d0) < EPS) {
          return 1;
        }
        t1 = v3.minus(v1).cross(v3.minus(v4)) / d0;
        t2 = v2.minus(v1).cross(v3.minus(v1)) / d0;
        if ((EPS < t1 && t1 < 1 - EPS) && (-EPS < t2 && t2 < 1 + EPS)) {
          return t1;
        }
        return 1;
      };
      mid = function(v1, v2, t) {
        return new Vec2(v1.x * (1 - t) + v2.x * t, v1.y * (1 - t) + v2.y * t);
      };
      reflect = function(p, ax1, ax2) {
        var s;

        s = ax2.minus(ax1);
        s = s.dot(1 / s.length());
        return s.dot(p.minus(ax1).dot(s) * 2).minus(p).plus(ax1).plus(ax1);
      };
      v0 = this.start.v;
      v1 = this.end.v;
      path = ['M', v0.x, v0.y];
      hit_count = 0;
      while (true) {
        get_t = (function(m) {
          return cross(v0, v1, m.end1.v, m.end2.v);
        });
        min_mirror = min_by_key(get_t, mirrors);
        min_t = get_t(min_mirror);
        mid_point = mid(v0, v1, min_t);
        path.push('L', mid_point.x, mid_point.y);
        if (min_t > 1 - EPS) {
          break;
        }
        v1 = reflect(v1, min_mirror.end1.v, min_mirror.end2.v);
        v0 = mid_point;
        hit_count += 1;
        if (hit_count > MAX_HIT_COUNT) {
          warn('Hit count large than ' + MAX_HIT_COUNT + '. Aborted.');
          break;
        }
      }
      this.line.attr('path', path);
      this.line_origin.attr('path', ['M', this.start.v.x, this.start.v.y, 'L', this.end.v.x, this.end.v.y]);
      if (hit_count <= MAX_HIT_COUNT) {
        return info('Finished in ' + hit_count + ' hits.');
      }
    };

    return Lazer;

  })();

  Mirror = (function() {
    function Mirror(paper, v1, v2) {
      this.line = paper.path([]).attr({
        stroke: "#000",
        strokeWidth: 1
      });
      this.end1 = new ControlPoint(paper, v1);
      this.end2 = new ControlPoint(paper, v2);
      this.update();
    }

    Mirror.prototype.update = function() {
      var v1, v2;

      v1 = this.end1.v;
      v2 = this.end2.v;
      return this.line.attr('path', ['M', v1.x, v1.y, 'L', v2.x, v2.y]);
    };

    Mirror.prototype.remove = function() {
      var obj, _i, _len, _ref, _results;

      _ref = [this.end1, this.end2, this.line];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        _results.push(obj.remove());
      }
      return _results;
    };

    return Mirror;

  })();

  Manager = (function() {
    function Manager() {
      var _this = this;

      this.paper = Raphael('paper', 800, 600);
      this.lazer = null;
      this.mirrors = [];
      $('#btn_update').click(function() {
        return _this.reload_input();
      });
      $('#btn_reset').click(function() {
        return _this.reset();
      });
      info('Input data and then press "Update"');
    }

    Manager.prototype.reset = function() {
      $('#input_data').val('');
      return this.clear();
    };

    Manager.prototype.clear = function() {
      var mirror, _i, _len, _ref;

      if (this.lazer) {
        this.lazer.remove();
      }
      this.lazer = null;
      _ref = this.mirrors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mirror = _ref[_i];
        mirror.remove();
      }
      return this.mirrors = [];
    };

    Manager.prototype.reload_input = function() {
      var angle, distance, end_x, end_y, format, i, mirror, numbers, update, x, _i, _len, _ref,
        _this = this;

      this.clear();
      format = $('#format').val();
      if (format === 'plain') {
        numbers = $('#input_data').val().trim().split(/\ +/).map(parseFloat);
      } else if (format === 'MMA') {
        numbers = $('#input_data').val().trim().replace(/[{}]/g, '').split(/[\ ,]/).map(parseFloat).filter(function(x) {
          return !isNaN(x);
        });
      }
      if (numbers.length < 4 || numbers.length % 4 !== 0) {
        warn('Invalid data. Data should be more than 4 numbers and multiples of 4.');
        return;
      }
      if (((function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = numbers.length; _i < _len; _i++) {
          x = numbers[_i];
          if (isNaN(x)) {
            _results.push(1);
          }
        }
        return _results;
      })()).length !== 0) {
        warn('Data should numbers');
        return;
      }
      angle = numbers[2];
      if ($('#degree').is(':checked')) {
        angle *= Math.PI / 180;
      }
      distance = numbers[3];
      numbers[2] = end_x = numbers[0] + Math.cos(angle) * distance;
      numbers[3] = end_y = numbers[1] + Math.sin(angle) * distance;
      numbers = this.adjust_numbers(numbers);
      this.lazer = this.build_lazer.apply(this, numbers.slice(0, 4));
      this.mirrors = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 4, _ref = numbers.length - 1; _i <= _ref; i = _i += 4) {
          _results.push(this.build_mirror.apply(this, numbers.slice(i, i + 4)));
        }
        return _results;
      }).call(this);
      update = function() {
        return _this.lazer.update(_this.mirrors);
      };
      this.lazer.start.move(update);
      this.lazer.end.move(update);
      _ref = this.mirrors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mirror = _ref[_i];
        update = (function(mirror) {
          return function() {
            mirror.update();
            return _this.lazer.update(_this.mirrors);
          };
        })(mirror);
        mirror.end1.move(update);
        mirror.end2.move(update);
      }
      this.lazer.update(this.mirrors);
      return info('Done');
    };

    Manager.prototype.adjust_numbers = function(a) {
      var convert_x, convert_y, end_x, end_y, i, result, scale, x0, x1, xc, xs, y0, y1, yc, ys, _i, _ref,
        _this = this;

      if (!$('#end_visible').is(':checked')) {
        end_x = a[2];
        end_y = a[3];
        a[2] = a[0];
        a[3] = a[1];
      }
      xs = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = a.length - 1; _i <= _ref; i = _i += 2) {
          _results.push(a[i]);
        }
        return _results;
      })();
      ys = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 1, _ref = a.length - 1; _i <= _ref; i = _i += 2) {
          _results.push(a[i]);
        }
        return _results;
      })();
      x0 = Math.min.apply(Math, xs);
      x1 = Math.max.apply(Math, xs);
      y0 = Math.min.apply(Math, ys);
      y1 = Math.max.apply(Math, ys);
      if (!$('#end_visible').is(':checked')) {
        a[2] = end_x;
        a[3] = end_y;
      }
      scale = Math.min(this.paper.width / (x1 - x0), this.paper.height / (y1 - y0)) / 1.2;
      xc = (x1 + x0) / 2;
      yc = (y1 + y0) / 2;
      if (!isFinite(scale)) {
        scale = 1;
        xc = this.paper.width / 2;
        yc = this.paper.height / 2;
      }
      convert_x = function(x) {
        return (x - xc) * scale + _this.paper.width / 2;
      };
      convert_y = function(y) {
        return (y - yc) * scale + _this.paper.height / 2;
      };
      result = [];
      for (i = _i = 0, _ref = a.length - 1; _i <= _ref; i = _i += 2) {
        result.push(convert_x(a[i]), convert_y(a[i + 1]));
      }
      return result;
    };

    Manager.prototype.build_lazer = function(x1, y1, x2, y2) {
      var lazer;

      return lazer = new Lazer(this.paper, new Vec2(x1, y1), new Vec2(x2, y2));
    };

    Manager.prototype.build_mirror = function(x1, y1, x2, y2) {
      return new Mirror(this.paper, new Vec2(x1, y1), new Vec2(x2, y2));
    };

    return Manager;

  })();

  $(function() {
    var manager;

    return manager = new Manager();
  });

}).call(this);
